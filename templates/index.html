<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Сборник Стихов</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #38bdf8;
            --text-color: #374151;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
        }

        /* НОВЫЙ СТИЛЬ для форматированного текста стиха */
        .poem-content {
            white-space: pre-wrap;
            line-height: 1.6;
            font-family: inherit;
            font-size: 1rem;
            color: var(--text-color);
            margin: 0;
        }

        /* Добавляем стили для Markdown-тегов, генерируемых библиотекой: */
        .poem-content em {
            font-style: italic;
        }

        .poem-content strong {
            font-weight: 600;
        }

        /* Стили для Модального окна */
        .modal {
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            visibility: hidden;
            background-color: rgba(0, 0, 0, 0.6);
        }

        .modal.open {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>

<body class="bg-gray-50 min-h-screen">

    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">

        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
        <div class="mb-4 space-y-2">
            {% for category, message in messages %}
            <div
                class="p-3 text-sm rounded-lg {% if category == 'error' %}bg-red-100 text-red-700{% elif category == 'success' %}bg-green-100 text-green-700{% else %}bg-sky-100 text-sky-700{% endif %}">
                {{ message }}
            </div>
            {% endfor %}
        </div>
        {% endif %}
        {% endwith %}

        <header class="flex justify-between items-center pb-6 border-b border-gray-200">
            <h1 class="text-3xl font-extrabold text-gray-900 tracking-tight">Сборник Стихов</h1>
            <nav class="space-x-4 flex items-center">
                {% if current_user.is_authenticated %}
                <a href="{{ url_for('profile') }}"
                    class="text-sm font-medium text-gray-600 hover:text-sky-600 transition-colors">Профиль</a>
                {% if is_admin %}
                <a href="{{ url_for('admin_panel') }}"
                    class="text-sm font-medium text-gray-600 hover:text-sky-600 transition-colors">Админ-панель</a>
                {% endif %}
                <a href="{{ url_for('logout') }}"
                    class="text-sm font-medium text-red-600 hover:text-red-800 transition-colors">Выйти</a>
                {% else %}
                <a href="{{ url_for('login') }}"
                    class="text-sm font-medium text-gray-600 hover:text-sky-600 transition-colors">Войти</a>
                <a href="{{ url_for('register') }}"
                    class="text-sm font-medium text-sky-600 hover:text-sky-700 transition-colors">Регистрация</a>
                {% endif %}
            </nav>
        </header>

        <div class="mt-6 flex flex-col sm:flex-row sm:justify-between sm:items-center">
            <div class="flex space-x-2 p-1 bg-white rounded-xl shadow-lg border border-gray-100 mb-4 sm:mb-0"
                id="tab-container">
                <button data-filter="pinned"
                    class="tab-btn px-4 py-2 text-sm font-semibold rounded-lg transition-all duration-200 text-sky-600 bg-sky-100 active:scale-[0.98]">
                    <span id="tab-count-pinned">0</span> Изучаю
                </button>

                <button data-filter="unread"
                    class="tab-btn px-4 py-2 text-sm font-semibold rounded-lg transition-all duration-200 text-gray-600 hover:text-sky-600">
                    <span id="tab-count-unread">0</span> Непрочитано
                </button>

                <button data-filter="read"
                    class="tab-btn px-4 py-2 text-sm font-semibold rounded-lg transition-all duration-200 text-gray-600 hover:text-sky-600">
                    <span id="tab-count-read">0</span> Прочитано
                </button>

                <button data-filter="unfiltered" id="tab-unfiltered"
                    class="tab-btn px-4 py-2 text-sm font-semibold rounded-lg transition-all duration-200 text-gray-600 hover:text-sky-600 {% if not show_all_tab %}hidden{% endif %}">
                    Все
                </button>
            </div>

            <div class="flex space-x-2 items-center">
                <span class="text-sm font-medium text-gray-500 hidden sm:block">Сортировать по:</span>
                <div class="flex space-x-2 bg-white rounded-xl shadow-lg p-1 border border-gray-100"
                    id="sort-container">
                    <button data-sort="title" data-order="none"
                        class="sort-btn px-3 py-1 text-xs font-medium rounded-lg transition-all duration-200 text-gray-600 hover:bg-gray-100 hover:text-gray-800">
                        Названию
                    </button>
                    <button data-sort="author" data-order="none"
                        class="sort-btn px-3 py-1 text-xs font-medium rounded-lg transition-all duration-200 text-gray-600 hover:bg-gray-100 hover:text-gray-800">
                        Автору
                    </button>
                    <button data-sort="lines" data-order="none"
                        class="sort-btn px-3 py-1 text-xs font-medium rounded-lg transition-all duration-200 text-gray-600 hover:bg-gray-100 hover:text-gray-800">
                        Длине
                    </button>
                </div>
            </div>
        </div>


        <div class="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="poem-list-container">
        </div>

    </div>

    <div id="poem-modal"
        class="modal fixed inset-0 z-50 flex items-center justify-center p-4 transition-opacity duration-300">
        <div
            class="modal-content bg-white rounded-xl shadow-2xl w-full max-w-2xl p-6 sm:p-8 transform transition-transform duration-300 scale-95 modal-transition-target">

            <div class="flex justify-between items-start mb-4">
                <div>
                    <h2 class="text-3xl font-extrabold text-gray-900 mb-1" id="modal-poem-title"></h2>
                    <p class="text-lg text-gray-600" id="modal-poem-author"></p>
                </div>
                <button onclick="closeModal()"
                    class="text-gray-400 hover:text-gray-600 transition-colors focus:outline-none">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>

            <div class="max-h-[60vh] overflow-y-auto mb-6 pr-4">
                <div class="poem-content" id="modal-poem-text"></div>
            </div>

            <div class="flex justify-between items-center border-t pt-4">
                <div class="flex space-x-3">
                    <button id="pin-poem-btn"
                        class="flex items-center space-x-1 px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium rounded-lg hover:bg-sky-50 hover:text-sky-600 transition-colors focus:outline-none">
                        <span id="pin-text">Закрепить</span>
                    </button>

                    <button id="mark-read-btn"
                        class="flex items-center space-x-1 px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium rounded-lg hover:bg-sky-50 hover:text-sky-600 transition-colors focus:outline-none">
                        <span id="read-text">Пометить прочитанным</span>
                    </button>
                </div>
                {% if is_admin %}
                <a href="#" id="edit-poem-link"
                    class="text-sm font-medium text-sky-600 hover:text-sky-800 transition-colors">Редактировать</a>
                {% endif %}
            </div>
        </div>
    </div>


    <script>
        const allData = {{ poems | tojson }};
        const readTitlesInitial = {{ read_titles | tojson }};
        const pinnedTitleInitial = {{ pinned_title | tojson }};
        const isAuthenticated = {{ current_user.is_authenticated | tojson }};
        const isAdmin = {{ is_admin | tojson }};
        const showAllTabSetting = {{ show_all_tab | tojson }};

        let allPoems = []; // Будет заполнено в window.onload
        let readTitles = new Set(readTitlesInitial);
        let pinnedTitle = pinnedTitleInitial;
        let currentFilter = 'pinned'; // Фильтр по умолчанию
        let currentSort = { type: 'lines', order: 'desc' }; // Сортировка по умолчанию

        // Кэширование DOM-элементов
        const modal = document.getElementById('poem-modal');
        const listContainer = document.getElementById('poem-list-container');
        const tabContainer = document.getElementById('tab-container');
        const sortContainer = document.getElementById('sort-container');
        const pinButton = document.getElementById('pin-poem-btn');
        const readButton = document.getElementById('mark-read-btn');
        const pinText = document.getElementById('pin-text');
        const readText = document.getElementById('read-text');
        const editLink = document.getElementById('edit-poem-link');

        // Иконки SVG
        const iconPin = '<svg class="w-4 h-4 fill-current text-sky-600" viewBox="0 0 24 24"><path d="M16 12V4.5l-2.5 2.5V12h-3V7l-2.5-2.5V12H5v2h2v4.75l-1.5 1.5H18l-1.5-1.5V14h2v-2h-3zm-2 0V7l2.5-2.5V12h-2.5z"/></svg>';
        const iconUnpin = '<svg class="w-4 h-4 fill-current" viewBox="0 0 24 24"><path d="M16 12V4.5l-2.5 2.5V12h-3V7l-2.5-2.5V12H5v2h2v4.75l-1.5 1.5H18l-1.5-1.5V14h2v-2h-3zm-2 0V7l2.5-2.5V12h-2.5z"/></svg>';
        const iconRead = '<svg class="w-4 h-4 fill-current text-sky-600" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
        const iconUnread = '<svg class="w-4 h-4 fill-current" viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>';


        // --- ОСНОВНАЯ ЛОГИКА ФИЛЬТРАЦИИ И ОТОБРАЖЕНИЯ ---

        /**
         * Определяет, соответствует ли стих текущему фильтру.
         * @param {Object} poem 
         */
        function poemMatchesFilter(poem) {
            const isRead = readTitles.has(poem.title);
            const isPinned = poem.title === pinnedTitle;

            switch (currentFilter) {
                case 'pinned':
                    return isPinned;
                case 'unread':
                    return !isRead;
                case 'read':
                    return isRead;
                case 'unfiltered':
                    return true;
                default:
                    return true;
            }
        }

        /**
         * Сортирует массив стихов.
         * @param {Array<Object>} poems
         */
        function sortPoems(poems) {
            const { type, order } = currentSort;
            const direction = order === 'asc' ? 1 : -1;

            return poems.sort((a, b) => {
                let valA, valB;

                if (type === 'lines') {
                    valA = a.lineCount;
                    valB = b.lineCount;
                } else if (type === 'author') {
                    valA = a.author.toLowerCase();
                    valB = b.author.toLowerCase();
                } else if (type === 'title') {
                    valA = a.title.toLowerCase();
                    valB = b.title.toLowerCase();
                } else {
                    return 0;
                }

                if (valA < valB) return -1 * direction;
                if (valA > valB) return 1 * direction;
                return 0;
            });
        }

        /**
         * Отрисовывает карточку стиха.
         * @param {Object} poem 
         * @returns {string} HTML-строка карточки
         */
        function renderPoemCard(poem) {
            const isRead = readTitles.has(poem.title);
            const isPinned = poem.title === pinnedTitle;
            const readClass = isRead ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-700';
            const readText = isRead ? 'Прочитано' : 'Не прочитано';
            const pinnedIcon = isPinned ? `<span class="text-sky-500 mr-1">★</span>` : '';

            return `
                <div class="bg-white rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 transform hover:-translate-y-0.5 border border-gray-100 p-6 flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold text-gray-900 mb-1 leading-snug flex items-start">
                            ${pinnedIcon}
                            <span class="flex-grow">${poem.title}</span>
                        </h3>
                        <p class="text-sm text-gray-500 font-medium">${poem.author}</p>
                    </div>
                    <div class="mt-4 flex items-center justify-between">
                        <span class="px-3 py-1 text-xs font-medium rounded-full ${readClass}">
                            ${readText}
                        </span>
                        <button onclick="showModal(${poem.id})" 
                            class="text-sm font-semibold text-sky-600 hover:text-sky-800 transition-colors focus:outline-none view-poem-btn"
                            data-poem-id="${poem.id}">
                            Читать (строк: ${poem.lineCount})
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * Обновляет счетчики вкладок.
         */
        function updateTabCounts() {
            const readCount = allPoems.filter(p => readTitles.has(p.title)).length;
            const pinnedCount = allPoems.filter(p => p.title === pinnedTitle).length;
            const unreadCount = allPoems.length - readCount;

            document.getElementById('tab-count-pinned').textContent = pinnedCount;
            document.getElementById('tab-count-unread').textContent = unreadCount;
            document.getElementById('tab-count-read').textContent = readCount;

            // Если выбран фильтр "Изучаю" и ничего не закреплено, переключаем на "Непрочитано"
            if (currentFilter === 'pinned' && pinnedCount === 0) {
                if (unreadCount > 0) {
                    switchFilter('unread', true); // Принудительно переключаем, но без повторного рендера
                } else if (readCount > 0) {
                    switchFilter('read', true);
                } else {
                    switchFilter('unfiltered', true);
                }
            }
        }


        /**
         * Главная функция для фильтрации, сортировки и отрисовки.
         */
        function filterAndRender() {
            // 1. Фильтрация
            let filteredPoems;
            if (isAuthenticated) {
                filteredPoems = allPoems.filter(poemMatchesFilter);
            } else {
                // Для неаутентифицированных пользователей показываем все
                filteredPoems = allPoems;
            }

            // 2. Сортировка
            const sortedPoems = sortPoems(filteredPoems);

            // 3. Рендеринг
            listContainer.innerHTML = '';
            if (sortedPoems.length === 0) {
                listContainer.innerHTML = `<p class="text-center text-gray-500 col-span-full py-12">Нет стихов, соответствующих выбранному фильтру/настройкам.</p>`;
            } else {
                sortedPoems.forEach((poem, index) => {
                    // Присваиваем ID в объекте для простоты доступа из модального окна
                    poem.id = index;
                    listContainer.innerHTML += renderPoemCard(poem);
                });
            }

            // 4. Обновление счетчиков (может влиять на активный фильтр)
            updateTabCounts();
        }

        /**
         * Переключает активный фильтр.
         * @param {string} filterType 
         * @param {boolean} skipRender Флаг для пропуска повторного рендера
         */
        function switchFilter(filterType, skipRender = false) {
            currentFilter = filterType;

            // Обновление UI вкладок
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.dataset.filter === filterType) {
                    btn.classList.add('bg-sky-100', 'text-sky-600');
                    btn.classList.remove('bg-gray-100', 'text-gray-600', 'hover:bg-sky-50', 'hover:text-sky-600');
                } else {
                    btn.classList.remove('bg-sky-100', 'text-sky-600');
                    btn.classList.add('bg-gray-100', 'text-gray-600', 'hover:bg-sky-50', 'hover:text-sky-600');
                }
            });

            if (!skipRender) {
                filterAndRender();
            }
        }

        // --- ЛОГИКА МОДАЛЬНОГО ОКНА ---

        /**
         * Показывает модальное окно с деталями стиха.
         * @param {number} poemId
         */
        function showModal(poemId) {
            if (!isAuthenticated) {
                alert('Для просмотра стихов, пожалуйста, войдите или зарегистрируйтесь.');
                window.location.href = '{{ url_for("login") }}';
                return;
            }

            const poem = allPoems.find(p => p.id === poemId);
            if (!poem) return;

            // 1. Заполнение основных данных
            document.getElementById('modal-poem-title').textContent = poem.title;
            document.getElementById('modal-poem-author').textContent = poem.author;

            // !!! КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: Используем innerHTML для HTML-текста (Markdown-форматирование)
            document.getElementById('modal-poem-text').innerHTML = poem.text;

            // 2. Настройка кнопок
            const isRead = readTitles.has(poem.title);
            const isPinned = poem.title === pinnedTitle;

            // Кнопка "Закрепить"
            pinButton.dataset.title = poem.title;
            pinButton.innerHTML = isPinned ? iconPin + `<span id="pin-text">Открепить</span>` : iconUnpin + `<span id="pin-text">Закрепить</span>`;

            // Кнопка "Прочитано"
            readButton.dataset.title = poem.title;
            readButton.innerHTML = isRead ? iconRead + `<span id="read-text">Пометить непрочитанным</span>` : iconUnread + `<span id="read-text">Пометить прочитанным</span>`;

            // Кнопка "Редактировать"
            if (isAdmin && editLink) {
                editLink.href = `{{ url_for('edit_poem', title='TEMP') }}`.replace('TEMP', encodeURIComponent(poem.title));
            }

            modal.classList.add('open');
        }

        function closeModal() {
            modal.classList.remove('open');
        }

        // --- ЛОГИКА AJAX (КНОПКИ) ---

        async function toggleReadStatus(title) {
            if (!isAuthenticated) return;
            try {
                const response = await fetch('{{ url_for("toggle_read") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.action === 'marked') {
                        readTitles.add(title);
                        readButton.innerHTML = iconRead + `<span id="read-text">Пометить непрочитанным</span>`;
                    } else {
                        readTitles.delete(title);
                        readButton.innerHTML = iconUnread + `<span id="read-text">Пометить прочитанным</span>`;
                    }
                    filterAndRender(); // Перерендеринг списка
                } else {
                    alert('Ошибка при обновлении статуса.');
                }
            } catch (e) {
                console.error('AJAX error:', e);
                alert('Произошла ошибка сети.');
            }
        }

        async function togglePinStatus(title) {
            if (!isAuthenticated) return;
            try {
                const response = await fetch('{{ url_for("toggle_pin") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title })
                });

                if (response.ok) {
                    const result = await response.json();

                    // Обновляем глобальное состояние закрепления
                    pinnedTitle = result.pinned_title;

                    if (result.action === 'pinned') {
                        pinButton.innerHTML = iconPin + `<span id="pin-text">Открепить</span>`;
                    } else {
                        pinButton.innerHTML = iconUnpin + `<span id="pin-text">Закрепить</span>`;
                    }

                    // Если пользователь на вкладке "Изучаю", фильтр может измениться
                    filterAndRender();
                } else {
                    alert('Ошибка при закреплении стиха.');
                }
            } catch (e) {
                console.error('AJAX error:', e);
                alert('Произошла ошибка сети.');
            }
        }


        // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

        // Обработчики кнопок модального окна
        readButton.addEventListener('click', () => {
            const title = readButton.dataset.title;
            if (title) toggleReadStatus(title);
        });

        pinButton.addEventListener('click', () => {
            const title = pinButton.dataset.title;
            if (title) togglePinStatus(title);
        });


        // Обработчики вкладок фильтрации
        tabContainer.addEventListener('click', (event) => {
            const targetButton = event.target.closest('.tab-btn');
            if (!targetButton) return;

            // Если неаутентифицирован, позволяем только 'unfiltered' (Все), если он виден
            if (!isAuthenticated && targetButton.dataset.filter !== 'unfiltered') {
                alert('Для использования фильтров, пожалуйста, войдите.');
                window.location.href = '{{ url_for("login") }}';
                return;
            }

            const filterType = targetButton.dataset.filter;
            switchFilter(filterType);
        });

        // Обработчики кнопок сортировки
        sortContainer.addEventListener('click', (event) => {
            const targetButton = event.target.closest('.sort-btn');
            if (!targetButton) return;

            const sortType = targetButton.dataset.sort;
            let sortOrder = targetButton.dataset.order;

            // 1. Если сортируем по тому же столбцу, меняем порядок
            if (currentSort.type === sortType) {
                sortOrder = (currentSort.order === 'asc' || currentSort.order === 'none') ? 'desc' : 'asc';
            } else {
                // 2. Если новый столбец, устанавливаем asc по умолчанию
                sortOrder = sortType === 'lines' ? 'desc' : 'asc'; // Длину удобнее смотреть с большего
            }

            // 3. Обновляем текущее состояние сортировки
            currentSort = { type: sortType, order: sortOrder };

            // 4. Обновляем UI для всех заголовков
            document.querySelectorAll('.sort-btn').forEach(h => {
                // Сброс всех стилей и символов
                h.classList.remove('bg-sky-100', 'text-sky-600', 'font-bold');
                h.classList.add('bg-gray-100', 'text-gray-600');

                const span = h.querySelector('.order-symbol');
                if (span) span.remove();
            });

            // 5. Устанавливаем новый порядок и метку для текущей кнопки
            targetButton.classList.add('bg-sky-100', 'text-sky-600', 'font-bold');
            targetButton.classList.remove('bg-gray-100', 'text-gray-600');

            const orderSymbol = sortOrder === 'asc' ? '▲' : '▼';
            const orderSpan = document.createElement('span');
            orderSpan.className = 'order-symbol ml-1';
            orderSpan.textContent = orderSymbol;
            targetButton.appendChild(orderSpan);

            filterAndRender();
        });


        // Закрытие модального окна по клику вне или по Esc
        modal.addEventListener('click', (event) => {
            if (event.target === modal) {
                closeModal();
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && modal.classList.contains('open')) {
                closeModal();
            }
        });

        // Инициализация при загрузке страницы
        window.onload = () => {
            // Добавляем ID (индекс) и счетчик строк в данные стихов
            allPoems = allData.map((poem, index) => ({
                ...poem,
                id: index,
                // Считаем строки по символу новой строки, который был в исходном тексте БД
                lineCount: poem.text.split('<br>').length // Markdown парсер может заменить \n на <br> или <p>
            }));

            // Устанавливаем активный фильтр по умолчанию (pinned, или unread/read, если pinned пуст)
            const pinnedCount = allPoems.filter(p => p.title === pinnedTitle).length;
            const unreadCount = allPoems.length - allPoems.filter(p => readTitles.has(p.title)).length;
            const readCount = allPoems.filter(p => readTitles.has(p.title)).length;

            let defaultFilter = 'unfiltered'; // Безопасное значение по умолчанию
            if (isAuthenticated) {
                defaultFilter = 'pinned';
                if (pinnedCount === 0) {
                    defaultFilter = unreadCount > 0 ? 'unread' : (readCount > 0 ? 'read' : 'unfiltered');
                }
            } else {
                defaultFilter = 'unfiltered';
            }

            // Если "Все" скрыто, используем определенную логику
            if (!showAllTabSetting && defaultFilter === 'unfiltered') {
                defaultFilter = unreadCount > 0 ? 'unread' : 'read';
            }

            // Запускаем счетчики, фильтрацию и отрисовку
            switchFilter(defaultFilter, true); // Переключаем фильтр без рендера
            filterAndRender(); // Запускаем рендер

            // Устанавливаем активную сортировку
            document.querySelector(`.sort-btn[data-sort="${currentSort.type}"]`).click();

        };
    </script>
</body>

</html>